/**********************************************************
 * This file is generated by the 20-sim C++ Code Generator
 *
 *  file:  Controller.cpp
 *  subm:  Controller
 *  model: Controller
 *  expmt: JIWY-TheoreticalModel
 *  date:  July 1, 2021
 *  time:  2:55:59 PM
 *  user:  20-sim 4.8 Campus License
 *  from:  Universiteit Twente
 *  build: 4.8.3.10415
 **********************************************************/

/* Standard include files */
#include <stdio.h>
#include <math.h>
/* Include the header for memcpy and memset
 * You may need to change this into <memory.h> for older compilers
 */
#include <string.h>

/* 20-sim include files */
#include "Controller.h"

/* Delta margin used for end time checking */
const XXDouble c_delta = 1.0e-7;

/* this PRIVATE function sets the input variables from the input vector */
void Controller::CopyInputsToVariables(XXDouble *u)
{
	/* copy the input vector to the input variables */
	m_V[12] = u[0]; /* MeasuredPan */
	m_V[13] = u[1]; /* MeasuredTilt */
	m_V[14] = u[2]; /* SetPointPan */
	m_V[15] = u[3]; /* SetPointTilt */
}

/* this PRIVATE function uses the output variables to fill the output vector */
void Controller::CopyVariablesToOutputs(XXDouble *y)
{
	/* copy the output variables to the output vector */
	y[0] = m_V[10]; /* SteeringPan */
	y[1] = m_V[11]; /* SteeringTilt */
}

Controller::Controller(void)
{
	m_number_constants = 0;
	m_number_parameters = 8;
	m_number_initialvalues = 4;
	m_number_variables = 16;
	m_number_states = 4;
	m_number_rates = 4;
	m_number_matrices = 0;
	m_number_unnamed = 0;

	/* the variable arrays */
	m_C = new XXDouble[0 + 1];	/* constants */
	m_P = new XXDouble[8 + 1];	/* parameters */
	m_I = new XXDouble[4 + 1];	/* initial values */
	m_V = new XXDouble[16 + 1]; /* variables */
	m_s = new XXDouble[4 + 1];	/* states */
	m_R = new XXDouble[4 + 1];	/* rates (or new states) */
	m_M = new XXMatrix[0 + 1];	/* matrices */
	m_U = new XXDouble[0 + 1];	/* unnamed */
	m_workarray = new XXDouble[0 + 1];

	Reset(0.0);
	m_finish_time = 300.0;
}

void Controller::Reset(XXDouble starttime)
{
	m_start_time = starttime;
	m_step_size = 0.001;
	m_time = starttime;
	m_major = true;
	m_stop_run = false;

	/* Clear the allocated variable memory */
	memset(m_C, 0, (0 + 1) * sizeof(XXDouble));
	memset(m_P, 0, (8 + 1) * sizeof(XXDouble));
	memset(m_I, 0, (4 + 1) * sizeof(XXDouble));
	memset(m_V, 0, (16 + 1) * sizeof(XXDouble));
	memset(m_s, 0, (4 + 1) * sizeof(XXDouble));
	memset(m_R, 0, (4 + 1) * sizeof(XXDouble));
	memset(m_M, 0, (0 + 1) * sizeof(XXDouble));
	memset(m_U, 0, (0 + 1) * sizeof(XXDouble));
	memset(m_workarray, 0, (0 + 1) * sizeof(XXDouble));

	state = initialrun;
}

bool Controller::IsFinished(void)
{
	return (state == finished);
}

Controller::~Controller(void)
{
	/* free memory */
	delete[] m_C;
	delete[] m_P;
	delete[] m_I;
	delete[] m_V;
	delete[] m_s;
	delete[] m_R;
	delete[] m_M;
	delete[] m_U;
	delete[] m_workarray;
}

/* the initialization function for submodel */
void Controller::Initialize(XXDouble *u, XXDouble *y, XXDouble t)
{
	/* initialization phase (allocating memory) */
	m_initialize = true;
	m_stop_run = false;

	/* set the constants */

	/* set the parameters */
	m_P[0] = 0.3;	 /* ControllerPan\PID_Pan\kp {} */
	m_P[1] = 0.1;	 /* ControllerPan\PID_Pan\tauD {s} */
	m_P[2] = 0.1;	 /* ControllerPan\PID_Pan\beta {} */
	m_P[3] = 1000.0; /* ControllerPan\PID_Pan\tauI {s} */
	m_P[4] = 0.2;	 /* ControllerTilt\PID_Tilt\kp {} */
	m_P[5] = 0.2;	 /* ControllerTilt\PID_Tilt\tauD {s} */
	m_P[6] = 0.1;	 /* ControllerTilt\PID_Tilt\beta {} */
	m_P[7] = 1000.0; /* ControllerTilt\PID_Tilt\tauI {s} */

	/* set the initial values */
	m_I[0] = 0.0; /* ControllerPan\PID_Pan\pdstate_initial */
	m_I[1] = 0.0; /* ControllerPan\PID_Pan\pistate_initial */
	m_I[2] = 0.0; /* ControllerTilt\PID_Tilt\pdstate_initial */
	m_I[3] = 0.0; /* ControllerTilt\PID_Tilt\pistate_initial */

	/* set the states */
	m_s[0] = m_I[0]; /* ControllerPan\PID_Pan\pdstate */
	m_s[1] = m_I[1]; /* ControllerPan\PID_Pan\pistate */
	m_s[2] = m_I[2]; /* ControllerTilt\PID_Tilt\pdstate */
	m_s[3] = m_I[3]; /* ControllerTilt\PID_Tilt\pistate */

	/* set the matrices */

	/* (re-)initialize the integration method */
	myintegmethod.Initialize(this);

	/* copy the inputs */
	m_time = t;
	CopyInputsToVariables(u);

	/* calculate initial and static equations */
	CalculateInitial();
	CalculateStatic();
	CalculateInput();
	CalculateDynamic();
	CalculateOutput();

	/* Set the outputs */
	CopyVariablesToOutputs(y);

	/* end of initialization phase */
	m_initialize = false;

	state = mainrun;
}

/* the function that calculates the submodel */
void Controller::Calculate(XXDouble *u, XXDouble *y /*, XXDouble t*/)
{
	switch (state)
	{
	case initialrun: /* calculate the model for the first time */
		Initialize(u, y, 0.0);
		break;
	case mainrun: /* calculate the model */
		if ((m_time <= (m_finish_time - m_step_size + c_delta)) || (m_finish_time == 0.0))
		{
			/* another precessor submodel could determine the parameters of this submodel
				   and therefore the static parameter calculations need to be performed. */
			CalculateStatic();
			CopyInputsToVariables(u);
			CalculateInput();
			myintegmethod.Step();
			CalculateOutput();
			CopyVariablesToOutputs(y);
		}
		else
		{
			state = finished;
		}

		if ((m_stop_run == true) || ((m_finish_time != 0.0) && (m_time + c_delta >= m_finish_time)))
		{
			state = finished;
		}
		break;
	case finished:
		break;
	default:
		break;
	}
}

/* the termination function for submodel */
void Controller::Terminate(XXDouble *u, XXDouble *y /*, XXDouble t */)
{
	/* copy the inputs */
	CopyInputsToVariables(u);

	/* calculate the final model equations */
	CalculateFinal();

	/* set the outputs */
	CopyVariablesToOutputs(y);
}

/* This function calculates the initial equations of the model.
 * These equations are calculated before anything else
 */
void Controller::CalculateInitial(void)
{
}

/* This function calculates the static equations of the model.
 * These equations are only dependent from parameters and constants
 */
void Controller::CalculateStatic(void)
{
}

/* This function calculates the input equations of the model.
 * These equations are dynamic equations that must not change
 * in calls from the integration method (like random and delay).
 */
void Controller::CalculateInput(void)
{
}

/* This function calculates the dynamic equations of the model.
 * These equations are called from the integration method
 * to calculate the new model rates (that are then integrated).
 */
void Controller::CalculateDynamic(void)
{
	/* ControllerPan\MeasuredPan = MeasuredPan; */
	m_V[3] = m_V[12];

	/* ControllerTilt\MeasuredTilt = MeasuredTilt; */
	m_V[8] = m_V[13];

	/* ControllerPan\SetPointPan = SetPointPan; */
	m_V[4] = m_V[14];

	/* ControllerTilt\SetPointTilt = SetPointTilt; */
	m_V[9] = m_V[15];

	/* ControllerPan\PlusMinus1\output = ControllerPan\SetPointPan - ControllerPan\MeasuredPan; */
	m_V[2] = m_V[4] - m_V[3];

	/* ControllerTilt\PlusMinus\output = ControllerTilt\SetPointTilt - ControllerTilt\MeasuredTilt; */
	m_V[7] = m_V[9] - m_V[8];

	/* ControllerPan\PID_Pan\pdout = ControllerPan\PID_Pan\pdstate + ((ControllerPan\PID_Pan\kp * ControllerPan\PlusMinus1\output) / ControllerPan\PID_Pan\beta); */
	m_V[1] = m_s[0] + ((m_P[0] * m_V[2]) / m_P[2]);

	/* ControllerPan\PID_Pan\pirate = ControllerPan\PID_Pan\pdout / ControllerPan\PID_Pan\tauI; */
	m_R[1] = m_V[1] / m_P[3];

	/* ControllerPan\PID_Pan\output = ControllerPan\PID_Pan\pistate + ControllerPan\PID_Pan\pdout; */
	m_V[0] = m_s[1] + m_V[1];

	/* ControllerTilt\PID_Tilt\pdout = ControllerTilt\PID_Tilt\pdstate + ((ControllerTilt\PID_Tilt\kp * ControllerTilt\PlusMinus\output) / ControllerTilt\PID_Tilt\beta); */
	m_V[6] = m_s[2] + ((m_P[4] * m_V[7]) / m_P[6]);

	/* ControllerTilt\PID_Tilt\pirate = ControllerTilt\PID_Tilt\pdout / ControllerTilt\PID_Tilt\tauI; */
	m_R[3] = m_V[6] / m_P[7];

	/* ControllerTilt\PID_Tilt\output = ControllerTilt\PID_Tilt\pistate + ControllerTilt\PID_Tilt\pdout; */
	m_V[5] = m_s[3] + m_V[6];

	/* ControllerPan\PID_Pan\pdrate = (ControllerPan\PID_Pan\kp * ControllerPan\PlusMinus1\output - ControllerPan\PID_Pan\pdout) / (ControllerPan\PID_Pan\beta * ControllerPan\PID_Pan\tauD); */
	m_R[0] = (m_P[0] * m_V[2] - m_V[1]) / (m_P[2] * m_P[1]);

	/* ControllerTilt\PID_Tilt\pdrate = (ControllerTilt\PID_Tilt\kp * ControllerTilt\PlusMinus\output - ControllerTilt\PID_Tilt\pdout) / (ControllerTilt\PID_Tilt\beta * ControllerTilt\PID_Tilt\tauD); */
	m_R[2] = (m_P[4] * m_V[7] - m_V[6]) / (m_P[6] * m_P[5]);
}

/* This function calculates the output equations of the model.
 * These equations are not needed for calculation of the rates
 * and are kept separate to make the dynamic set of equations smaller.
 * These dynamic equations are called often more than one time for each
 * integration step that is taken. This makes model computation much faster.
 */
void Controller::CalculateOutput(void)
{
	/* SteeringPan = ControllerPan\PID_Pan\output; */
	m_V[10] = m_V[0];

	/* SteeringTilt = ControllerTilt\PID_Tilt\output; */
	m_V[11] = m_V[5];
}

/* This function calculates the final equations of the model.
 * These equations are calculated after all the calculations
 * are performed
 */
void Controller::CalculateFinal(void)
{
}

bool Controller::SetFinishTime(XXDouble newtime)
{
	if ((newtime <= 0.0) || (newtime > m_time))
	{
		m_finish_time = newtime;
		return true;
	}

	return false;
}
